import { autoUpdate as T, computePosition as W, shift as _, hide as B, flip as P, offset as H, autoPlacement as L, arrow as N, platform as v } from "@floating-ui/dom";
import { debounce as z } from "lodash-es";
import { offsetParent as G } from "composed-offset-position";
import { D as w, i as M } from "./runtime.js";
import { g as V } from "./dom.js";
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.1.0 */
(function() {
  if (M()) {
    const e = v.getOffsetParent;
    v.getOffsetParent = (i) => e(i, G);
  }
})();
function U(t) {
  const e = window.devicePixelRatio || 1;
  return Math.round(t * e) / e;
}
const O = (
  /* we export arrow function to allow us to spy on it during testing */
  async (t, {
    referenceEl: e,
    floatingEl: i,
    overlayPositioning: n = "absolute",
    placement: a,
    flipDisabled: s,
    flipPlacements: r,
    offsetDistance: o,
    offsetSkidding: d,
    arrowEl: g,
    type: D
  }) => {
    if (!e || !i)
      return;
    const m = V(i) === "rtl", {
      x: R,
      y: S,
      placement: b,
      strategy: k,
      middlewareData: p
    } = await W(e, i, {
      strategy: n,
      placement: a === "auto" || a === "auto-start" || a === "auto-end" ? void 0 : x(a, m),
      middleware: J({
        placement: a,
        flipDisabled: s,
        flipPlacements: r?.map((f) => x(f, m)),
        offsetDistance: o,
        offsetSkidding: d,
        arrowEl: g,
        type: D
      })
    });
    if (g && p.arrow) {
      const { x: f, y: j } = p.arrow, c = b.split("-")[0], y = f != null ? "left" : "top", C = Q[c], I = { left: "", top: "", bottom: "", right: "" };
      "floatingLayout" in t && (t.floatingLayout = c === "left" || c === "right" ? "horizontal" : "vertical"), Object.assign(g.style, {
        ...I,
        [y]: `${y == "left" ? f : j}px`,
        [c]: "100%",
        transform: C
      });
    }
    const h = p.hide?.referenceHidden ? "hidden" : null, $ = h ? "none" : null;
    i.setAttribute(q, b), Object.assign(i.style, {
      pointerEvents: $,
      position: k,
      transform: `translate(${U(R)}px,${U(S)}px)`,
      visibility: h
    });
  }
), q = "data-placement", F = [
  "top",
  "bottom",
  "right",
  "left",
  "top-start",
  "top-end",
  "bottom-start",
  "bottom-end",
  "right-start",
  "right-end",
  "left-start",
  "left-end",
  "leading",
  "trailing",
  "leading-start",
  "leading-end",
  "trailing-start",
  "trailing-end"
], ot = "bottom-start", st = "bottom-end", rt = {
  animation: "calcite-floating-ui-anim",
  animationActive: "calcite-floating-ui-anim--active"
};
function J({
  placement: t,
  flipDisabled: e,
  flipPlacements: i,
  offsetDistance: n,
  offsetSkidding: a,
  arrowEl: s,
  type: r
}) {
  const o = [_(), B()];
  return r === "menu" && o.push(
    P({
      fallbackPlacements: i || ["top-start", "top", "top-end", "bottom-start", "bottom", "bottom-end"]
    })
  ), o.push(
    H({
      mainAxis: typeof n == "number" ? n : 0,
      crossAxis: typeof a == "number" ? a : 0
    })
  ), t === "auto" || t === "auto-start" || t === "auto-end" ? o.push(
    L({ alignment: t === "auto-start" ? "start" : t === "auto-end" ? "end" : null })
  ) : e || o.push(P(i ? { fallbackPlacements: i } : {})), s && o.push(
    N({
      element: s
    })
  ), o;
}
function lt(t, e) {
  const i = t.filter(
    (n) => F.includes(n)
  );
  return i.length !== t.length && console.warn(
    `${e.tagName}: Invalid value found in: flipPlacements. Try any of these: ${F.map((n) => `"${n}"`).join(", ").trim()}`,
    { el: e }
  ), i;
}
function x(t, e = !1) {
  const i = ["left", "right"];
  return e && i.reverse(), t.replace(/leading/gi, i[0]).replace(/trailing/gi, i[1]);
}
async function ft(t, e, i = !1) {
  if (!t.open || !e.floatingEl || !e.referenceEl)
    return;
  if (Object.assign(e.floatingEl.style, {
    display: "block",
    // initial positioning based on https://floating-ui.com/docs/computePosition#initial-layout
    position: e.overlayPositioning ?? "absolute"
  }), !l.get(t))
    return A(t);
  await (i ? K(t) : O)(t, e);
}
function K(t) {
  let e = u.get(t);
  return e || (e = z(O, w.reposition, {
    leading: !0,
    maxWait: w.reposition
  }), u.set(t, e), e);
}
const Q = {
  top: "",
  left: "rotate(-90deg)",
  bottom: "rotate(180deg)",
  right: "rotate(90deg)"
}, l = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
async function A(t) {
  const { referenceEl: e, floatingEl: i } = t;
  if (!i.isConnected)
    return;
  const n = M() ? T : (r, o, d) => (d(), () => {
  });
  l.set(t, { state: "pending" });
  let a;
  const s = n(
    e,
    i,
    // callback is invoked immediately
    () => {
      const r = t.reposition();
      a || (a = r);
    }
  );
  return l.set(t, { state: "active", cleanUp: s }), a;
}
function X(t) {
  const { floatingEl: e } = t;
  e && Object.assign(e.style, {
    display: "",
    pointerEvents: "",
    position: "",
    transform: "",
    visibility: ""
  });
}
async function ct(t) {
  const { floatingEl: e, referenceEl: i } = t;
  if (X(t), !(!e || !i) && (Y(t), !!t.open))
    return A(t);
}
function Y(t) {
  const { floatingEl: e, referenceEl: i } = t;
  if (!e || !i)
    return;
  const n = l.get(t);
  n?.state === "active" && n.cleanUp(), l.delete(t), u.get(t)?.cancel(), u.delete(t);
}
const E = 4, ut = Math.ceil(Math.hypot(E, E));
export {
  rt as F,
  Y as a,
  ot as b,
  ct as c,
  ut as d,
  st as e,
  lt as f,
  X as h,
  ft as r
};
