import v from "color";
import { h as I, i as R, j as b } from "./global.js";
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.1.0 */
const w = {
  channel: "channel",
  channels: "channels",
  colorField: "color-field",
  colorFieldScope: "scope--color-field",
  colorMode: "color-mode",
  colorModeContainer: "color-mode-container",
  container: "container",
  control: "control",
  controlAndScope: "control-and-scope",
  controlSection: "control-section",
  deleteColor: "delete-color",
  header: "header",
  hexAndChannelsGroup: "hex-and-channels-group",
  hexOptions: "color-hex-options",
  hueScope: "scope--hue",
  hueSlider: "hue-slider",
  opacityScope: "scope--opacity",
  opacitySlider: "opacity-slider",
  preview: "preview",
  previewAndSliders: "preview-and-sliders",
  saveColor: "save-color",
  savedColor: "saved-color",
  savedColors: "saved-colors",
  savedColorsButtons: "saved-colors-buttons",
  savedColorsSection: "saved-colors-section",
  scope: "scope",
  section: "section",
  slider: "slider",
  sliders: "sliders",
  splitSection: "section--split"
}, y = v("#007AC2"), z = "calcite-color-", X = {
  r: 255,
  g: 255,
  b: 255
}, B = {
  h: 360,
  s: 100,
  v: 100
}, N = B.h - 1, O = {
  min: 0,
  max: 100
}, G = {
  s: {
    gap: parseInt(b),
    slider: {
      height: 12
    },
    thumb: {
      radius: 7
    },
    preview: {
      size: 20
    },
    minWidth: 200
  },
  m: {
    gap: parseInt(R),
    slider: {
      height: 12
    },
    thumb: {
      radius: 7
    },
    preview: {
      size: 24
    },
    minWidth: 240
  },
  l: {
    gap: parseInt(I),
    slider: {
      height: 12
    },
    thumb: {
      radius: 7
    },
    preview: {
      size: 32
    },
    minWidth: 304
  }
}, P = 1, D = /^[0-9A-F]$/i, E = /^#[0-9A-F]{3}$/i, M = /^#[0-9A-F]{6}$/i, $ = /^#[0-9A-F]{4}$/i, x = /^#[0-9A-F]{8}$/i, U = (t) => Number((t * 100).toFixed()), q = (t) => Number((t / 100).toFixed(2));
function C(t, n = !1) {
  return h(t, n) || F(t, n);
}
function g(t, n, r) {
  return t ? t.length === n && r.test(t) : !1;
}
function h(t, n = !1) {
  return g(t, n ? 5 : 4, n ? $ : E);
}
function F(t, n = !1) {
  return g(t, n ? 9 : 7, n ? x : M);
}
function Y(t, n = !1, r = !1) {
  if (t = t.toLowerCase(), t.startsWith("#") || (t = `#${t}`), h(t, n))
    return A(H(t, n));
  if (n && r && C(
    t,
    !1
    /* we only care about RGB hex for conversion */
  )) {
    const i = h(t, !1);
    return A(H(`${t}${i ? "f" : "ff"}`, !0));
  }
  return t;
}
function j(t, n = !1) {
  return n ? t.hexa() : t.hex();
}
function A(t) {
  const { r: n, g: r, b: i } = t, o = S(n), a = S(r), d = S(i), l = "a" in t ? S(t.a * 255) : "";
  return `#${o}${a}${d}${l}`.toLowerCase();
}
function S(t) {
  return t.toString(16).padStart(2, "0");
}
function k(t) {
  const n = {
    ...t,
    a: t.alpha ?? 1
    /* Color() will omit alpha if 1 */
  };
  return delete n.alpha, n;
}
function K(t) {
  const n = { ...t, alpha: t.a ?? 1 };
  return delete n.a, n;
}
function H(t, n = !1) {
  if (!C(t, n))
    return null;
  t = t.replace("#", "");
  let r, i, o, a;
  if (t.length === 3 || t.length === 4) {
    const [l, p, f, u] = t.split("");
    r = parseInt(`${l}${l}`, 16), i = parseInt(`${p}${p}`, 16), o = parseInt(`${f}${f}`, 16), a = parseInt(`${u}${u}`, 16) / 255;
  } else
    r = parseInt(t.slice(0, 2), 16), i = parseInt(t.slice(2, 4), 16), o = parseInt(t.slice(4, 6), 16), a = parseInt(t.slice(6, 8), 16) / 255;
  return isNaN(a) ? { r, g: i, b: o } : { r, g: i, b: o, a };
}
const L = (t) => t, e = L({
  HEX: "hex",
  HEXA: "hexa",
  RGB_CSS: "rgb-css",
  RGBA_CSS: "rgba-css",
  HSL_CSS: "hsl-css",
  HSLA_CSS: "hsla-css"
}), s = L({
  RGB: "rgb",
  RGBA: "rgba",
  HSL: "hsl",
  HSLA: "hsla",
  HSV: "hsv",
  HSVA: "hsva"
});
function Z(t) {
  if (typeof t == "string") {
    if (t.startsWith("#")) {
      const { length: n } = t;
      if (n === 4 || n === 7)
        return e.HEX;
      if (n === 5 || n === 9)
        return e.HEXA;
    }
    if (t.startsWith("rgba("))
      return e.RGBA_CSS;
    if (t.startsWith("rgb("))
      return e.RGB_CSS;
    if (t.startsWith("hsl("))
      return e.HSL_CSS;
    if (t.startsWith("hsla("))
      return e.HSLA_CSS;
  }
  if (typeof t == "object") {
    if (c(t, "r", "g", "b"))
      return c(t, "a") ? s.RGBA : s.RGB;
    if (c(t, "h", "s", "l"))
      return c(t, "a") ? s.HSLA : s.HSL;
    if (c(t, "h", "s", "v"))
      return c(t, "a") ? s.HSVA : s.HSV;
  }
  return null;
}
function c(t, ...n) {
  return n.every((r) => r && t && `${r}` in t);
}
function J(t, n) {
  return t?.rgb().array().toString() === n?.rgb().array().toString();
}
function Q(t) {
  return t === e.HEXA || t === e.RGBA_CSS || t === e.HSLA_CSS || t === s.RGBA || t === s.HSLA || t === s.HSVA;
}
function V(t) {
  return t === e.HEX ? e.HEXA : t === e.RGB_CSS ? e.RGBA_CSS : t === e.HSL_CSS ? e.HSLA_CSS : t === s.RGB ? s.RGBA : t === s.HSL ? s.HSLA : t === s.HSV ? s.HSVA : t;
}
function tt(t) {
  return t === e.HEXA ? e.HEX : t === e.RGBA_CSS ? e.RGB_CSS : t === e.HSLA_CSS ? e.HSL_CSS : t === s.RGBA ? s.RGB : t === s.HSLA ? s.HSL : t === s.HSVA ? s.HSV : t;
}
const T = 1, _ = T * 2;
function nt(t, n, r) {
  const i = r ? G.l.preview.size : n.preview.size, o = t - _, a = n.gap * 3;
  return Math.max(o - a - i, 0);
}
function et(t) {
  const r = t - _;
  return {
    width: Math.max(r, 0),
    height: Math.max(Math.floor(r / 1.8), 0)
  };
}
export {
  e as C,
  y as D,
  B as H,
  O,
  X as R,
  G as S,
  F as a,
  h as b,
  U as c,
  D as d,
  et as e,
  z as f,
  nt as g,
  j as h,
  C as i,
  Q as j,
  K as k,
  J as l,
  w as m,
  Y as n,
  q as o,
  Z as p,
  tt as q,
  A as r,
  N as s,
  V as t,
  k as u,
  P as v,
  H as w
};
